// Copyright 2025 Redpanda Data, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package generator

import (
	"testing"

	. "github.com/onsi/gomega"
)

func TestE2EAnnotationBehavior(t *testing.T) {
	g := NewWithT(t)
	
	// Test that the example service generates the expected tool names
	// This verifies the complete pipeline: proto -> annotation -> generated code
	// NOTE: This test would require importing the generated example code,
	// but we avoid that here to prevent proto registration conflicts
	
	// Instead, we test the core logic
	g.Expect(validateToolName("create_example")).ToNot(HaveOccurred())
	g.Expect(validateToolName("get_example")).ToNot(HaveOccurred())
	// Auto-generated names use lenient validation
	g.Expect(validateToolNameStrict("example_v1_ExampleService_DeleteExample", false)).ToNot(HaveOccurred())
}

func TestE2EValidatedToolNames(t *testing.T) {
	g := NewWithT(t)
	
	// Verify that custom annotation names follow strict validation rules
	customToolNames := []string{
		"create_example",
		"get_example", 
		"list_all_resources",
		"update_resource_legacy",
	}
	
	for _, name := range customToolNames {
		// Custom tool names should follow strict snake_case rules
		err := validateToolName(name)
		g.Expect(err).ToNot(HaveOccurred(), "Custom tool name %q should be valid", name)
	}
	
	// Verify that auto-generated names follow lenient validation rules
	autoGeneratedNames := []string{
		"example_v1_ExampleService_DeleteExample",
	}
	
	for _, name := range autoGeneratedNames {
		// Auto-generated names can use mixed case
		err := validateToolNameStrict(name, false)
		g.Expect(err).ToNot(HaveOccurred(), "Auto-generated tool name %q should be valid", name)
	}
}

func TestE2EDescriptionCleaning(t *testing.T) {
	g := NewWithT(t)
	
	// Test the cleanComment function directly
	input := `buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
@ignore-comment Ignore these linter rules
CreateExample creates a new example resource with the provided configuration.
This demonstrates option-based custom tool naming.`

	result := cleanComment(input)
	g.Expect(result).ToNot(ContainSubstring("buf:lint:"))
	g.Expect(result).ToNot(ContainSubstring("@ignore-comment"))
	
	// Should contain the actual description
	g.Expect(result).To(ContainSubstring("CreateExample creates a new example resource"))
}